/**
 * This Source Code Form is part of the HexaGlue project.
 * Copyright (c) 2025 Scalastic
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 *
 * Commercial licensing options are available for organizations wishing
 * to use HexaGlue under terms different from the MPL 2.0.
 * Contact: info@hexaglue.io
 */
package io.hexaglue.core.naming;

import io.hexaglue.spi.naming.NameRole;
import io.hexaglue.spi.naming.NameStrategySpec;
import io.hexaglue.spi.naming.QualifiedName;
import java.util.Objects;
import java.util.Optional;

/**
 * Default implementation of {@link NameStrategySpec}.
 *
 * <p>
 * This strategy implements conventional naming patterns for generated infrastructure code:
 * <ul>
 *   <li>Generated packages follow a configurable base package with role-specific segments</li>
 *   <li>Type names use PascalCase with optional suffixes</li>
 *   <li>Member names use camelCase</li>
 *   <li>Constants use CONSTANT_CASE</li>
 * </ul>
 * </p>
 *
 * <h2>Package Structure</h2>
 * <p>
 * The default strategy generates packages under a base package, optionally mirroring
 * the domain package structure or using flat packages with role-based segments.
 * </p>
 *
 * <p>
 * Example configurations:
 * <pre>
 * Base: "com.example.infrastructure"
 * Domain: "com.example.domain.customer"
 * Role: TYPE with hint "persistence"
 * → "com.example.infrastructure.persistence"
 * </pre>
 * </p>
 *
 * <h2>Name Generation</h2>
 * <p>
 * Names are generated by:
 * <ol>
 *   <li>Applying role-specific conventions (case, separators)</li>
 *   <li>Adding prefixes or suffixes based on hints</li>
 *   <li>Sanitizing to ensure valid Java identifiers</li>
 * </ol>
 * </p>
 *
 * <h2>Thread Safety</h2>
 * <p>
 * Instances are immutable and thread-safe.
 * </p>
 *
 * <h2>Usage</h2>
 * <pre>{@code
 * NameStrategySpec strategy = DefaultNameStrategy.builder()
 *     .basePackage("com.example.infrastructure")
 *     .mirrorDomainPackages(false)
 *     .build();
 *
 * String pkg = strategy.packageName("com.example.domain", NameRole.TYPE, "persistence");
 * // → "com.example.infrastructure.persistence"
 *
 * String name = strategy.simpleName("Customer", NameRole.TYPE, "Entity");
 * // → "CustomerEntity"
 * }</pre>
 */
public final class DefaultNameStrategy implements NameStrategySpec {

    private final String basePackage;
    private final boolean mirrorDomainPackages;
    private final String componentKey;

    private DefaultNameStrategy(Builder builder) {
        this.basePackage = requireNonBlank(builder.basePackage, "basePackage");
        this.mirrorDomainPackages = builder.mirrorDomainPackages;
        this.componentKey = normalizeBlankToNull(builder.componentKey);
    }

    /**
     * Creates a builder for configuring the naming strategy.
     *
     * @return builder (never {@code null})
     */
    public static Builder builder() {
        return new Builder();
    }

    /**
     * Creates a default naming strategy with the given base package.
     *
     * <p>
     * This is a convenience method equivalent to:
     * <pre>{@code
     * DefaultNameStrategy.builder().basePackage(basePackage).build()
     * }</pre>
     * </p>
     *
     * @param basePackage base package for generated code (not blank)
     * @return naming strategy (never {@code null})
     */
    public static DefaultNameStrategy of(String basePackage) {
        return builder().basePackage(basePackage).build();
    }

    @Override
    public String basePackage() {
        return basePackage;
    }

    @Override
    public String packageName(String domainPackage, NameRole role, String hint) {
        Objects.requireNonNull(role, "role");

        // If mirroring domain packages and domain package is provided, derive from it
        if (mirrorDomainPackages && domainPackage != null && !domainPackage.isBlank()) {
            String sanitized = NameSanitizer.sanitizePackage(domainPackage);
            // Append role-based segment if hint is provided
            if (hint != null && !hint.isBlank()) {
                String segment = NameRules.suggestPackageSegment(role, hint);
                return sanitized + "." + segment;
            }
            return sanitized;
        }

        // Use base package with optional role segment
        if (hint != null && !hint.isBlank()) {
            String segment = NameRules.suggestPackageSegment(role, hint);
            return basePackage + "." + segment;
        }

        return basePackage;
    }

    @Override
    public String simpleName(String baseSimpleName, NameRole role, String hint) {
        Objects.requireNonNull(role, "role");
        String base = requireNonBlank(baseSimpleName, "baseSimpleName");

        // Apply role-specific conventions
        String conventional = NameRules.applyConvention(base, role);

        // Add suffix from hint if provided
        if (hint != null && !hint.isBlank()) {
            String suffix = NameSanitizer.toPascalCase(hint);
            return conventional + suffix;
        }

        return conventional;
    }

    @Override
    public String memberName(String base, NameRole role, String hint) {
        Objects.requireNonNull(role, "role");
        String baseName = requireNonBlank(base, "base");

        // Apply role-specific conventions
        String conventional = NameRules.applyConvention(baseName, role);

        // For members, hints are typically not used as suffixes
        // but if needed, the caller can compose names explicitly
        return conventional;
    }

    @Override
    public String resourcePath(String base, NameRole role, String hint) {
        Objects.requireNonNull(role, "role");
        String basePath = requireNonBlank(base, "base");

        // Resource paths are typically left as-is, but we ensure forward slashes
        String normalized = basePath.replace('\\', '/');

        // If hint is provided, it might indicate a subdirectory
        if (hint != null && !hint.isBlank()) {
            String segment = hint.trim().replace('\\', '/');
            return normalized + "/" + segment;
        }

        return normalized;
    }

    @Override
    public String docPath(String base, NameRole role, String hint) {
        Objects.requireNonNull(role, "role");
        String basePath = requireNonBlank(base, "base");

        // Documentation paths are similar to resource paths
        String normalized = basePath.replace('\\', '/');

        if (hint != null && !hint.isBlank()) {
            String segment = hint.trim().replace('\\', '/');
            return normalized + "/" + segment;
        }

        return normalized;
    }

    @Override
    public Optional<String> componentKey() {
        return Optional.ofNullable(componentKey);
    }

    /**
     * Creates a qualified type name using this strategy's package naming.
     *
     * @param domainPackage domain package (nullable)
     * @param simpleName    simple name (not blank)
     * @param hint          package hint (nullable)
     * @return qualified name (never {@code null})
     */
    public QualifiedName qualifiedType(String domainPackage, String simpleName, String hint) {
        String pkg = packageName(domainPackage, NameRole.PACKAGE, hint);
        String simple = simpleName(simpleName, NameRole.TYPE, null);
        return qualifiedTypeName(pkg, simple);
    }

    @Override
    public String toString() {
        return "DefaultNameStrategy[basePackage=" + basePackage + ", mirrorDomain=" + mirrorDomainPackages + "]";
    }

    /**
     * Builder for {@link DefaultNameStrategy}.
     */
    public static final class Builder {
        private String basePackage;
        private boolean mirrorDomainPackages = false;
        private String componentKey;

        private Builder() {}

        /**
         * Sets the base package for generated code.
         *
         * <p>
         * This is the root package under which all generated infrastructure code will be placed.
         * </p>
         *
         * @param basePackage base package (not blank)
         * @return this builder
         */
        public Builder basePackage(String basePackage) {
            this.basePackage = basePackage;
            return this;
        }

        /**
         * Sets whether to mirror the domain package structure in generated packages.
         *
         * <p>
         * When enabled:
         * <ul>
         *   <li>If domain package is {@code "com.example.domain.customer"}</li>
         *   <li>Generated package might be {@code "com.example.domain.customer.persistence"}</li>
         * </ul>
         * </p>
         *
         * <p>
         * When disabled (default):
         * <ul>
         *   <li>All generated code goes under the base package</li>
         *   <li>Example: {@code "com.example.infrastructure.persistence"}</li>
         * </ul>
         * </p>
         *
         * @param mirrorDomainPackages {@code true} to mirror domain packages
         * @return this builder
         */
        public Builder mirrorDomainPackages(boolean mirrorDomainPackages) {
            this.mirrorDomainPackages = mirrorDomainPackages;
            return this;
        }

        /**
         * Sets an optional component key for grouping artifacts.
         *
         * @param componentKey component key (nullable)
         * @return this builder
         */
        public Builder componentKey(String componentKey) {
            this.componentKey = componentKey;
            return this;
        }

        /**
         * Builds the naming strategy.
         *
         * @return naming strategy (never {@code null})
         */
        public DefaultNameStrategy build() {
            return new DefaultNameStrategy(this);
        }
    }

    private static String requireNonBlank(String value, String label) {
        Objects.requireNonNull(value, label);
        String trimmed = value.trim();
        if (trimmed.isEmpty()) {
            throw new IllegalArgumentException(label + " must not be blank");
        }
        return trimmed;
    }

    private static String normalizeBlankToNull(String value) {
        if (value == null) return null;
        String trimmed = value.trim();
        return trimmed.isEmpty() ? null : trimmed;
    }
}
