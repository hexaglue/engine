/**
 * This Source Code Form is part of the HexaGlue project.
 * Copyright (c) 2025 Scalastic
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 *
 * Commercial licensing options are available for organizations wishing
 * to use HexaGlue under terms different from the MPL 2.0.
 * Contact: info@hexaglue.io
 */
package io.hexaglue.core.internal.ir.domain.analysis;

import io.hexaglue.core.internal.InternalMarker;
import io.hexaglue.core.internal.ir.SourceRef;
import io.hexaglue.core.internal.ir.SourceRefs;
import io.hexaglue.core.internal.ir.domain.DomainService;
import java.util.Objects;
import java.util.Optional;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.lang.model.util.Elements;

/**
 * Extracts domain services from analyzed source elements.
 *
 * <p>
 * This extractor identifies and builds {@link DomainService} instances from source elements
 * that represent pure business rules and domain logic. Domain services are discovered but
 * never generated by HexaGlue.
 * </p>
 *
 * <h2>Domain Service Recognition</h2>
 * <p>
 * A type is considered a domain service if it:
 * </p>
 * <ul>
 *   <li>Is named with "Service", "Calculator", "Engine", "Policy", "Strategy", etc.</li>
 *   <li>Contains business logic methods without persistence or I/O</li>
 *   <li>Is stateless or has only configuration state</li>
 *   <li>Works with domain entities and value objects</li>
 *   <li>Resides in domain packages (*.domain.*, *.model.service.*)</li>
 * </ul>
 *
 * <h2>Exclusions</h2>
 * <p>
 * The following are NOT domain services:
 * </p>
 * <ul>
 *   <li><strong>Application services:</strong> Orchestration and use case coordination</li>
 *   <li><strong>Infrastructure services:</strong> Repositories, gateways, adapters</li>
 *   <li><strong>Technical services:</strong> Logging, caching, validation frameworks</li>
 * </ul>
 *
 * <h2>Extraction Process</h2>
 * <p>
 * For each domain service, the extractor:
 * </p>
 * <ol>
 *   <li>Validates it represents pure business logic</li>
 *   <li>Extracts qualified and simple names</li>
 *   <li>Captures javadoc description</li>
 *   <li>Records source element reference</li>
 *   <li>Builds {@link DomainService} instance</li>
 * </ol>
 *
 * <h2>Design Goals</h2>
 * <ul>
 *   <li><strong>Conservative:</strong> Only recognize clear domain services</li>
 *   <li><strong>Informational:</strong> Services are analyzed for context, not generation</li>
 *   <li><strong>Minimal:</strong> Capture only essential metadata</li>
 * </ul>
 *
 * <h2>Thread Safety</h2>
 * <p>
 * This class is stateless and safe for concurrent use.
 * </p>
 *
 * <h2>Usage Example</h2>
 * <pre>{@code
 * DomainServiceExtractor extractor = new DomainServiceExtractor();
 * TypeElement pricingServiceElement = ...;
 *
 * if (extractor.isDomainService(pricingServiceElement)) {
 *     Optional<DomainService> service = extractor.extract(pricingServiceElement);
 * }
 * }</pre>
 */
@InternalMarker(reason = "Internal domain analysis; not exposed to plugins")
public final class DomainServiceExtractor {

    private final Elements elementUtils;

    /**
     * Creates a domain service extractor.
     *
     * @param elementUtils element utilities (not {@code null})
     * @throws NullPointerException if elementUtils is null
     */
    public DomainServiceExtractor(Elements elementUtils) {
        this.elementUtils = Objects.requireNonNull(elementUtils, "elementUtils");
    }

    /**
     * Extracts a domain service from a source element.
     *
     * <p>
     * This implementation uses JSR-269 APIs to analyze the type element and determine if it
     * represents a domain service.
     * </p>
     *
     * @param typeElement source type element (not {@code null}, must be {@code TypeElement})
     * @return extracted domain service if valid, or empty if not a domain service
     * @throws NullPointerException     if typeElement is null
     * @throws IllegalArgumentException if typeElement is not a TypeElement
     */
    public Optional<DomainService> extract(Object typeElement) {
        Objects.requireNonNull(typeElement, "typeElement");

        if (!(typeElement instanceof TypeElement te)) {
            throw new IllegalArgumentException("typeElement must be a TypeElement");
        }

        // Only extract from classes (not interfaces, enums, etc.)
        if (!isDomainService(te)) {
            return Optional.empty();
        }

        // Extract basic information
        String qualifiedName = te.getQualifiedName().toString();
        String simpleName = te.getSimpleName().toString();

        // Extract description from javadoc
        String description = extractDocumentation(te);

        // Create stable source reference
        SourceRef ref = SourceRefs.coerce(te, qualifiedName, SourceRef.Kind.TYPE);

        // Build domain service
        DomainService service = DomainService.builder()
                .qualifiedName(qualifiedName)
                .simpleName(simpleName)
                .description(description)
                .sourceRef(ref)
                .build();

        return Optional.of(service);
    }

    /**
     * Extracts documentation from a type element.
     *
     * @param typeElement type element (not {@code null})
     * @return documentation if present, or {@code null}
     */
    private String extractDocumentation(TypeElement typeElement) {
        String docComment = elementUtils.getDocComment(typeElement);
        if (docComment != null && !docComment.isBlank()) {
            // Extract first sentence as description
            int firstPeriod = docComment.indexOf('.');
            if (firstPeriod > 0) {
                return docComment.substring(0, firstPeriod + 1).trim();
            }
            return docComment.trim();
        }
        return null;
    }

    /**
     * Extracts a domain service from explicit parameters.
     *
     * <p>
     * This method is useful when domain service information is already known and needs to be
     * packaged into a {@link DomainService} instance.
     * </p>
     *
     * @param qualifiedName qualified service name (not {@code null})
     * @param simpleName    simple service name (not {@code null})
     * @param description   optional description (nullable)
     * @param sourceElement optional source element reference (nullable)
     * @return domain service (never {@code null})
     * @throws NullPointerException if any required parameter is null
     */
    public DomainService extractService(
            String qualifiedName, String simpleName, String description, Object sourceElement) {
        Objects.requireNonNull(qualifiedName, "qualifiedName");
        Objects.requireNonNull(simpleName, "simpleName");

        // Create stable source reference
        SourceRef ref = SourceRefs.coerce(sourceElement, qualifiedName, SourceRef.Kind.TYPE);

        return DomainService.builder()
                .qualifiedName(qualifiedName)
                .simpleName(simpleName)
                .description(description)
                .sourceRef(ref)
                .build();
    }

    /**
     * Determines whether a type element represents a domain service.
     *
     * <p>
     * Domain services are distinguished from application services and infrastructure
     * services by their location, naming, and purpose.
     * </p>
     *
     * @param typeElement source type element (not {@code null})
     * @return {@code true} if this is a domain service
     */
    public boolean isDomainService(TypeElement typeElement) {
        Objects.requireNonNull(typeElement, "typeElement");

        // Must be a class (not interface, enum, annotation, record)
        if (typeElement.getKind() != ElementKind.CLASS) {
            return false;
        }

        // Must not be abstract (domain services should be concrete)
        if (typeElement.getModifiers().contains(Modifier.ABSTRACT)) {
            return false;
        }

        String qualifiedName = typeElement.getQualifiedName().toString();
        String simpleName = typeElement.getSimpleName().toString();

        // Check package name
        String packageName = extractPackageName(qualifiedName);
        if (!isDomainPackage(packageName)) {
            return false;
        }

        // Check naming convention
        if (!looksLikeDomainService(simpleName)) {
            return false;
        }

        // Exclude infrastructure packages
        if (isInfrastructurePackage(packageName)) {
            return false;
        }

        return true;
    }

    /**
     * Extracts package name from qualified name.
     *
     * @param qualifiedName qualified name (not {@code null})
     * @return package name or empty string
     */
    private String extractPackageName(String qualifiedName) {
        int lastDot = qualifiedName.lastIndexOf('.');
        return lastDot > 0 ? qualifiedName.substring(0, lastDot) : "";
    }

    /**
     * Checks if a package name suggests infrastructure.
     *
     * @param packageName package name (not {@code null})
     * @return {@code true} if infrastructure package
     */
    private boolean isInfrastructurePackage(String packageName) {
        return packageName.contains(".infrastructure.")
                || packageName.contains(".adapter.")
                || packageName.contains(".repository.")
                || packageName.contains(".persistence.")
                || packageName.endsWith(".infrastructure")
                || packageName.endsWith(".adapter");
    }

    /**
     * Determines if a type name suggests it's a domain service.
     *
     * <p>
     * Domain services typically have names like:
     * </p>
     * <ul>
     *   <li>PricingService, PricingCalculator, PricingEngine</li>
     *   <li>EligibilityChecker, EligibilityPolicy</li>
     *   <li>AllocationEngine, AllocationStrategy</li>
     * </ul>
     *
     * @param typeName type name to check (not {@code null})
     * @return {@code true} if name suggests domain service
     */
    public boolean looksLikeDomainService(String typeName) {
        Objects.requireNonNull(typeName, "typeName");

        return typeName.endsWith("Service")
                || typeName.endsWith("Calculator")
                || typeName.endsWith("Engine")
                || typeName.endsWith("Policy")
                || typeName.endsWith("Strategy")
                || typeName.endsWith("Checker")
                || typeName.endsWith("Validator");
    }

    /**
     * Determines if a package name suggests domain scope.
     *
     * <p>
     * Domain packages typically match patterns like:
     * </p>
     * <ul>
     *   <li>*.domain.*</li>
     *   <li>*.model.*</li>
     *   <li>*.core.*</li>
     * </ul>
     *
     * @param packageName package name to check (not {@code null})
     * @return {@code true} if package suggests domain scope
     */
    public boolean isDomainPackage(String packageName) {
        Objects.requireNonNull(packageName, "packageName");

        return packageName.contains(".domain.")
                || packageName.contains(".model.")
                || packageName.contains(".core.")
                || packageName.endsWith(".domain")
                || packageName.endsWith(".model")
                || packageName.endsWith(".core");
    }
}
