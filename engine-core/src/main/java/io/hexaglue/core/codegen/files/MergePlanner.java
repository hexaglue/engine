/**
 * This Source Code Form is part of the HexaGlue project.
 * Copyright (c) 2025 Scalastic
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 *
 * Commercial licensing options are available for organizations wishing
 * to use HexaGlue under terms different from the MPL 2.0.
 * Contact: info@hexaglue.io
 */
package io.hexaglue.core.codegen.files;

import io.hexaglue.spi.codegen.GeneratedHeader;
import io.hexaglue.spi.codegen.MergeMode;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

/**
 * Plans and executes merge operations for generated files based on {@link MergeMode}.
 *
 * <p>
 * This class determines how to handle conflicts when a generated file would overwrite
 * an existing file. It coordinates header generation, custom block preservation, and
 * merge strategy execution.
 * </p>
 *
 * <h2>Design Rationale</h2>
 * <p>
 * Centralizing merge logic enables:
 * </p>
 * <ul>
 *   <li>Consistent merge behavior across all file types</li>
 *   <li>Testable merge decisions without file I/O</li>
 *   <li>Clear separation between merge planning and file writing</li>
 *   <li>Support for multiple merge strategies with minimal code duplication</li>
 * </ul>
 *
 * <h2>Merge Strategies</h2>
 * <p>
 * The planner supports all {@link MergeMode} strategies:
 * </p>
 * <ul>
 *   <li><strong>OVERWRITE:</strong> Replace existing file unconditionally</li>
 *   <li><strong>MERGE_CUSTOM_BLOCKS:</strong> Preserve custom block content</li>
 *   <li><strong>WRITE_ONCE:</strong> Keep existing file if present</li>
 *   <li><strong>FAIL_IF_EXISTS:</strong> Error if file exists</li>
 * </ul>
 *
 * <h2>Planning Process</h2>
 * <p>
 * The planner produces a {@link MergePlan} which contains:
 * </p>
 * <ul>
 *   <li>The final content to write (after merging)</li>
 *   <li>The action to take ({@code WRITE}, {@code SKIP}, {@code ERROR})</li>
 *   <li>Diagnostic information for logging and error reporting</li>
 * </ul>
 *
 * <h2>Thread Safety</h2>
 * <p>
 * This class is stateless and thread-safe.
 * </p>
 *
 * <h2>Example</h2>
 * <pre>{@code
 * MergePlan plan = MergePlanner.plan(
 *     newContent,
 *     existingContent,
 *     MergeMode.MERGE_CUSTOM_BLOCKS,
 *     header,
 *     customBlocks
 * );
 *
 * if (plan.action() == MergeAction.WRITE) {
 *     writeFile(plan.finalContent());
 * } else if (plan.action() == MergeAction.ERROR) {
 *     reportError(plan.message());
 * }
 * }</pre>
 */
public final class MergePlanner {

    private MergePlanner() {
        // Utility class, no instantiation
    }

    /**
     * Plans a merge operation for a file.
     *
     * @param newContent new file content generated by plugins (not {@code null})
     * @param existingContent existing file content if file exists (nullable)
     * @param mergeMode merge mode to apply (not {@code null})
     * @param header optional generated header to prepend (nullable)
     * @param customBlockIds IDs of custom blocks to preserve (not {@code null}, possibly empty)
     * @return merge plan (never {@code null})
     */
    public static MergePlan plan(
            String newContent,
            Optional<String> existingContent,
            MergeMode mergeMode,
            Optional<GeneratedHeader> header,
            List<String> customBlockIds) {
        Objects.requireNonNull(newContent, "newContent");
        Objects.requireNonNull(existingContent, "existingContent");
        Objects.requireNonNull(mergeMode, "mergeMode");
        Objects.requireNonNull(header, "header");
        Objects.requireNonNull(customBlockIds, "customBlockIds");

        // Prepare content with header if present
        String contentWithHeader = newContent;
        if (header.isPresent()) {
            String headerText = GeneratedHeaderEngine.renderJavaBlock(header.get());
            contentWithHeader = headerText + "\n" + newContent;
        }

        // Handle merge based on mode
        switch (mergeMode) {
            case OVERWRITE:
                return MergePlan.write(contentWithHeader, "Overwriting existing file");

            case MERGE_CUSTOM_BLOCKS:
                if (existingContent.isEmpty()) {
                    return MergePlan.write(contentWithHeader, "No existing file, writing new file");
                }
                return planCustomBlockMerge(contentWithHeader, existingContent.get(), customBlockIds);

            case WRITE_ONCE:
                if (existingContent.isPresent()) {
                    return MergePlan.skip("File already exists (WRITE_ONCE mode)");
                }
                return MergePlan.write(contentWithHeader, "No existing file, writing new file");

            case FAIL_IF_EXISTS:
                if (existingContent.isPresent()) {
                    return MergePlan.error("File already exists and FAIL_IF_EXISTS mode is active");
                }
                return MergePlan.write(contentWithHeader, "No existing file, writing new file");

            default:
                return MergePlan.error("Unsupported merge mode: " + mergeMode);
        }
    }

    /**
     * Plans a custom block merge operation.
     *
     * @param newContent new file content with custom block markers (not {@code null})
     * @param existingContent existing file content (not {@code null})
     * @param customBlockIds custom block IDs to preserve (not {@code null})
     * @return merge plan (never {@code null})
     */
    private static MergePlan planCustomBlockMerge(
            String newContent, String existingContent, List<String> customBlockIds) {
        try {
            // Extract custom blocks from existing file
            Map<String, String> preservedBlocks = CustomBlockEngine.extractBlocks(existingContent);

            // Detect orphaned blocks
            List<String> orphanedBlocks = CustomBlockEngine.detectOrphanedBlocks(existingContent, newContent);

            // Merge preserved blocks into new content
            String mergedContent = CustomBlockEngine.mergeBlocks(newContent, preservedBlocks);

            String message = orphanedBlocks.isEmpty()
                    ? "Merged custom blocks successfully"
                    : "Merged custom blocks (orphaned: " + String.join(", ", orphanedBlocks) + ")";

            return MergePlan.write(mergedContent, message);

        } catch (IllegalArgumentException e) {
            return MergePlan.error("Custom block merge failed: " + e.getMessage());
        }
    }

    /**
     * Represents the result of merge planning.
     */
    public static final class MergePlan {
        private final MergeAction action;
        private final String finalContent;
        private final String message;

        private MergePlan(MergeAction action, String finalContent, String message) {
            this.action = Objects.requireNonNull(action, "action");
            this.finalContent = finalContent; // nullable for SKIP and ERROR
            this.message = Objects.requireNonNull(message, "message");
        }

        /**
         * Creates a plan to write the given content.
         *
         * @param content content to write (not {@code null})
         * @param message descriptive message (not {@code null})
         * @return merge plan (never {@code null})
         */
        public static MergePlan write(String content, String message) {
            Objects.requireNonNull(content, "content");
            return new MergePlan(MergeAction.WRITE, content, message);
        }

        /**
         * Creates a plan to skip the write operation.
         *
         * @param message reason for skipping (not {@code null})
         * @return merge plan (never {@code null})
         */
        public static MergePlan skip(String message) {
            return new MergePlan(MergeAction.SKIP, null, message);
        }

        /**
         * Creates a plan indicating an error occurred.
         *
         * @param message error message (not {@code null})
         * @return merge plan (never {@code null})
         */
        public static MergePlan error(String message) {
            return new MergePlan(MergeAction.ERROR, null, message);
        }

        /**
         * Returns the action to take.
         *
         * @return merge action (never {@code null})
         */
        public MergeAction action() {
            return action;
        }

        /**
         * Returns the final content to write.
         *
         * <p>
         * This is only present when {@link #action()} is {@link MergeAction#WRITE}.
         * </p>
         *
         * @return final content if action is WRITE
         */
        public Optional<String> finalContent() {
            return Optional.ofNullable(finalContent);
        }

        /**
         * Returns a descriptive message about the merge decision.
         *
         * @return message (never {@code null})
         */
        public String message() {
            return message;
        }

        @Override
        public String toString() {
            return "MergePlan{action=" + action + ", message='" + message + "'}";
        }
    }

    /**
     * Action to take based on merge planning result.
     */
    public enum MergeAction {
        /**
         * Write the file with the merged content.
         */
        WRITE,

        /**
         * Skip writing the file (existing file should be preserved).
         */
        SKIP,

        /**
         * Error occurred during merge planning (report as diagnostic).
         */
        ERROR
    }
}
