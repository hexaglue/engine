/**
 * This Source Code Form is part of the HexaGlue project.
 * Copyright (c) 2025 Scalastic
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 *
 * Commercial licensing options are available for organizations wishing
 * to use HexaGlue under terms different from the MPL 2.0.
 * Contact: info@hexaglue.io
 */
package io.hexaglue.core.codegen.files;

import io.hexaglue.spi.codegen.GeneratedHeader;
import java.time.Instant;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.Objects;

/**
 * Renders {@link GeneratedHeader} metadata into formatted comment text for generated files.
 *
 * <p>
 * This engine converts structured header information into actual comment blocks that can
 * be inserted at the beginning of source files, resource files, or documentation files.
 * It supports multiple comment styles (Java-style, shell-style, Markdown-style, etc.).
 * </p>
 *
 * <h2>Design Rationale</h2>
 * <p>
 * Separating header rendering from file emission enables:
 * </p>
 * <ul>
 *   <li>Consistent header formatting across all generated artifacts</li>
 *   <li>Support for multiple comment styles (line, block, markup)</li>
 *   <li>Testable header generation without file I/O</li>
 *   <li>Centralized header policy enforcement</li>
 * </ul>
 *
 * <h2>Comment Styles</h2>
 * <p>
 * Supported comment styles:
 * </p>
 * <ul>
 *   <li><strong>JAVA_BLOCK:</strong> {@code /* ... *&#47;} style for Java/C/C++</li>
 *   <li><strong>JAVA_LINE:</strong> {@code // ...} style for Java/C/C++</li>
 *   <li><strong>SHELL:</strong> {@code # ...} style for shell scripts, properties, YAML</li>
 *   <li><strong>XML:</strong> {@code <!-- ... -->} style for XML/HTML</li>
 *   <li><strong>MARKDOWN:</strong> {@code > ...} style for Markdown blockquotes</li>
 * </ul>
 *
 * <h2>Header Content</h2>
 * <p>
 * A typical generated header includes:
 * </p>
 * <ul>
 *   <li>Generation attribution (tool name and version)</li>
 *   <li>Generation timestamp (optional)</li>
 *   <li>License information (optional)</li>
 *   <li>Copyright notice (optional)</li>
 *   <li>Warning about regeneration (standard)</li>
 * </ul>
 *
 * <h2>Thread Safety</h2>
 * <p>
 * This class is stateless and thread-safe.
 * </p>
 *
 * <h2>Example</h2>
 * <pre>{@code
 * GeneratedHeader header = GeneratedHeader.of(
 *     "HexaGlue",
 *     "MPL-2.0",
 *     "Copyright (c) 2025 Scalastic",
 *     Instant.now()
 * );
 *
 * String rendered = GeneratedHeaderEngine.render(header, CommentStyle.JAVA_BLOCK);
 * // Result:
 * // /*
 * //  * Generated by HexaGlue
 * //  * Date: 2025-01-15T10:30:00Z
 * //  * License: MPL-2.0
 * //  * Copyright (c) 2025 Scalastic
 * //  *
 * //  * DO NOT EDIT - This file is generated and will be overwritten
 * //  *&#47;
 * }</pre>
 */
public final class GeneratedHeaderEngine {

    private static final DateTimeFormatter ISO_FORMATTER = DateTimeFormatter.ISO_INSTANT.withZone(ZoneId.of("UTC"));

    private static final String DEFAULT_WARNING = "DO NOT EDIT - This file is generated and will be overwritten";

    private GeneratedHeaderEngine() {
        // Utility class, no instantiation
    }

    /**
     * Renders a header using Java block comment style.
     *
     * @param header header metadata (not {@code null})
     * @return rendered header text (never {@code null})
     */
    public static String renderJavaBlock(GeneratedHeader header) {
        Objects.requireNonNull(header, "header");
        return render(header, CommentStyle.JAVA_BLOCK);
    }

    /**
     * Renders a header using Java line comment style.
     *
     * @param header header metadata (not {@code null})
     * @return rendered header text (never {@code null})
     */
    public static String renderJavaLine(GeneratedHeader header) {
        Objects.requireNonNull(header, "header");
        return render(header, CommentStyle.JAVA_LINE);
    }

    /**
     * Renders a header using shell/properties comment style.
     *
     * @param header header metadata (not {@code null})
     * @return rendered header text (never {@code null})
     */
    public static String renderShell(GeneratedHeader header) {
        Objects.requireNonNull(header, "header");
        return render(header, CommentStyle.SHELL);
    }

    /**
     * Renders a header using XML comment style.
     *
     * @param header header metadata (not {@code null})
     * @return rendered header text (never {@code null})
     */
    public static String renderXml(GeneratedHeader header) {
        Objects.requireNonNull(header, "header");
        return render(header, CommentStyle.XML);
    }

    /**
     * Renders a header using Markdown blockquote style.
     *
     * @param header header metadata (not {@code null})
     * @return rendered header text (never {@code null})
     */
    public static String renderMarkdown(GeneratedHeader header) {
        Objects.requireNonNull(header, "header");
        return render(header, CommentStyle.MARKDOWN);
    }

    /**
     * Renders a header with the specified comment style.
     *
     * @param header header metadata (not {@code null})
     * @param style comment style (not {@code null})
     * @return rendered header text (never {@code null})
     */
    public static String render(GeneratedHeader header, CommentStyle style) {
        Objects.requireNonNull(header, "header");
        Objects.requireNonNull(style, "style");

        StringBuilder sb = new StringBuilder();

        // Build content lines
        sb.append("Generated by ").append(header.toolName());

        if (header.generatedAt().isPresent()) {
            sb.append('\n');
            sb.append("Date: ").append(formatInstant(header.generatedAt().get()));
        }

        if (header.license().isPresent()) {
            sb.append('\n');
            sb.append("License: ").append(header.license().get());
        }

        if (header.copyright().isPresent()) {
            sb.append('\n');
            sb.append(header.copyright().get());
        }

        sb.append('\n');
        sb.append('\n');
        sb.append(DEFAULT_WARNING);

        String content = sb.toString();

        // Wrap in comment style
        return wrapInCommentStyle(content, style);
    }

    /**
     * Wraps content in the specified comment style.
     *
     * @param content content to wrap (not {@code null})
     * @param style comment style (not {@code null})
     * @return wrapped content (never {@code null})
     */
    private static String wrapInCommentStyle(String content, CommentStyle style) {
        String[] lines = content.split("\n", -1);
        StringBuilder result = new StringBuilder();

        switch (style) {
            case JAVA_BLOCK:
                result.append("/*\n");
                for (String line : lines) {
                    result.append(" * ");
                    if (!line.isEmpty()) {
                        result.append(line);
                    }
                    result.append('\n');
                }
                result.append(" */\n");
                break;

            case JAVA_LINE:
                for (String line : lines) {
                    result.append("// ");
                    if (!line.isEmpty()) {
                        result.append(line);
                    }
                    result.append('\n');
                }
                break;

            case SHELL:
                for (String line : lines) {
                    result.append("# ");
                    if (!line.isEmpty()) {
                        result.append(line);
                    }
                    result.append('\n');
                }
                break;

            case XML:
                result.append("<!--\n");
                for (String line : lines) {
                    result.append("  ");
                    if (!line.isEmpty()) {
                        result.append(line);
                    }
                    result.append('\n');
                }
                result.append("-->\n");
                break;

            case MARKDOWN:
                for (String line : lines) {
                    result.append("> ");
                    if (!line.isEmpty()) {
                        result.append(line);
                    }
                    result.append('\n');
                }
                break;

            default:
                throw new IllegalArgumentException("Unsupported comment style: " + style);
        }

        return result.toString();
    }

    /**
     * Formats an instant as ISO-8601 UTC timestamp.
     *
     * @param instant instant to format (not {@code null})
     * @return formatted timestamp (never {@code null})
     */
    private static String formatInstant(Instant instant) {
        return ISO_FORMATTER.format(instant);
    }

    /**
     * Comment style for header rendering.
     */
    public enum CommentStyle {
        /**
         * Java/C/C++ block comment style: {@code /* ... *&#47;}.
         */
        JAVA_BLOCK,

        /**
         * Java/C/C++ line comment style: {@code // ...}.
         */
        JAVA_LINE,

        /**
         * Shell/properties/YAML comment style: {@code # ...}.
         */
        SHELL,

        /**
         * XML/HTML comment style: {@code <!-- ... -->}.
         */
        XML,

        /**
         * Markdown blockquote style: {@code > ...}.
         */
        MARKDOWN
    }
}
